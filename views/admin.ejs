<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Admin - Configuration Editor</title>
  <link rel="stylesheet" href="/styles.css" />
  <style>
      button{
        padding:10px;
      }
      .step-container {
        display: none;
      }
      .step-container.active {
        display: block;
      }
      .step-navigation {
        display: flex;
        justify-content: space-between;
        margin: 20px 0;
      }
      .step-indicator {
        text-align: center;
        margin: 20px 0;
        font-weight: bold;
      }
      /* Style for loading state */
      .saving {
        opacity: 0.7;
        pointer-events: none;
      }
      .saving::after {
        content: " Saving...";
        color: #666;
      }
      /* Styles for the rounding menu */
      .rounding-menu {
        margin-top: 30px;
        padding: 15px;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #f9f9f9;
      }
      .rounding-menu h3 {
        margin-top: 0;
      }
      .rounding-options {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 15px;
      }
      .rounding-option {
        display: flex;
        align-items: center;
        gap: 5px;
      }
      .rounding-option input[type="radio"] {
        margin: 0;
      }
      .rounding-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }
      .rounding-buttons button {
        flex: 1;
        min-width: 120px;
      }
      /* Highlight editable GBP fields */
      .editable-gbp {
        background-color: #e6f7ff;
        border: 1px solid #1890ff;
      }
      /* Style for calculated annual price display */
      .base-calculated-annual-price-display {
          background-color: #f0f0f0; /* Light grey background */
          color: #333; /* Darker text for contrast */
          font-weight: bold; /* Make it stand out slightly */
      }
  </style>
</head>
<body>
  <div class="titleDiv">
    <h1>System Configuration Editor</h1>
    <% if (message) { %>
      <div class="message"><%= message %></div>
    <% } %>
  </div>
  <div class="container">
    <div class="step-indicator">
      <h2 id="current-step-title">Step 1: Edit PPUs</h2> <!-- Updated initial title -->
    </div>
    <!-- Step 1: PPUs (was Step 2) -->
    <div id="step1" class="step-container active"> <!-- Changed ID and made active -->
      <h2>Per-User Pricing (PPU)</h2>
      <p>Per-User pricing is used when the user amount is lower than the lowest volume pricing tier.</p>
      <form id="ppus-form" action="/admin/updatePPUs" method="POST">
        <div class="variable-grid">
          <% Object.entries(ppus).forEach(([currency, values]) => { %>
            <div class="variable-card">
              <h3><%= currency %></h3>
              <label>Price</label>
              <input type="number" name="ppus[<%= currency %>][standard]"
                    value="<%= values.standard.toFixed(2) %>" step="0.01" min="0">
            </div>
          <% }) %>
        </div>
      </form>
      <div class="step-navigation">
        <button disabled>Previous</button>
        <button class="next-step" data-next="2">Next: Edit Base Prices</button> <!-- Updated data-next -->
      </div>
    </div>
    <!-- Step 2: Base Prices (was Step 3) -->
    <div id="step2" class="step-container"> <!-- Changed ID -->
      <h2>Monthly Base Prices for Volume Pricing (per user)</h2>
      <p>The monthly base price is used to calculate the volume pricing using the base price and volume discount.</p>
      <form id="base-prices-form" action="/admin/updateBasePrices" method="POST">
        <div class="variable-grid">
          <div class="variable-card">
            <h3>Base Prices</h3>
            <% Object.entries(basePrices.subscriptions).forEach(([currency, annualPrice]) => { %>
              <% const monthlyPrice = typeof annualPrice === 'number' ? (annualPrice / 12).toFixed(4) : '0.0000'; %>
              <label><%= currency %> Monthly Price</label>
              <!-- Input for Monthly Price -->
              <input
                type="number"
                name="monthlySubscriptions[<%= currency %>]"
                value="<%= monthlyPrice %>"
                step="0.0001"
                min="0"
                required
                class="base-monthly-price-input"
                data-currency="<%= currency %>"
              >
              <!-- Hidden input to store the calculated annual price for submission -->
              <input
                type="hidden"
                name="subscriptions[<%= currency %>]"
                value="<%= typeof annualPrice === 'number' ? annualPrice.toFixed(2) : '0.00' %>"
                class="base-annual-price-input"
                data-currency="<%= currency %>"
              >
              <!-- Display the calculated annual price -->
              <label><%= currency %> Annual Price (Calculated)</label>
              <input
                type="number"
                readonly
                value="<%= typeof annualPrice === 'number' ? annualPrice.toFixed(2) : '0.00' %>"
                class="base-calculated-annual-price-display"
                data-currency="<%= currency %>"
              >
            <% }) %>
          </div>
        </div>
      </form>
      <div class="step-navigation">
        <button class="prev-step" data-prev="1">Previous: PPUs</button> <!-- Updated data-prev -->
        <button class="next-step" data-next="3">Next: Edit Volume Pricing</button> <!-- Updated data-next -->
      </div>
    </div>
    <!-- Step 3: Volume Pricing (was Step 4) -->
    <div id="step3" class="step-container"> <!-- Changed ID -->
      <h2>Volume Pricing Tiers</h2>
      <p>Each box represents a pricing tier. Meaning that if the user amount if for example 1350, the pricing tier for 1400 users is used.</p>
      <p>The prices are calculated by either editing the volume discount or the GBP price. Both ways the prices match with each other.</p>
      <div class="add-tier-form">
        <h3>Add New Pricing Tier</h3>
        <form id="add-tier-form">
          <div class="form-group">
            <label>User Count</label>
            <input type="number" name="userCount" required min="1" id="new-tier-user-count">
          </div>
          <div class="form-group">
            <label>Volume Discount (%)</label>
             <!-- Keep a very small step for maximum input precision -->
            <input type="number" name="volumeDiscount" step="0.00000000000000000001" min="0" max="100" required id="new-tier-discount">
          </div>
          <% Object.entries(basePrices.subscriptions).forEach(([currency, basePrice]) => { %>
            <div class="form-group">
              <label><%= currency %> Total Price</label>
              <input type="number" name="subscriptions[<%= currency %>]" step="0.01" min="0" required
                     disabled class="new-tier-calculated-price" data-currency="<%= currency %>">
            </div>
          <% }) %>
          <button type="submit" id="add-tier-button">Add New Tier</button>
        </form>
      </div>
      <!-- Existing Volume Pricing Tiers -->
      <form id="volume-pricing-form" action="/admin/updateVolumePricing" method="POST">
        <div class="variable-grid" id="volume-pricing-grid">
          <% volumePricing.forEach((tier) => { %>
            <div class="variable-card" data-tier-id="<%= tier.id %>">
              <h3><%= tier.userCount.toLocaleString() %> Users</h3>
              <input type="hidden" name="tiers[<%= tier.id %>][id]" value="<%= tier.id %>">
              <input type="hidden" name="tiers[<%= tier.id %>][userCount]" value="<%= tier.userCount %>">
              <!-- Display discount with maximum JS precision using toString() -->
              <label>Volume Discount %</label>
              <input type="number" name="tiers[<%= tier.id %>][volumeDiscount]"
                    value="<%= (tier.volumeDiscount * 100).toString() %>"
                    step="0.00000000000000000001" min="0" max="100"
                    class="discount-input" data-tier-id="<%= tier.id %>">
              <% Object.entries(basePrices.subscriptions).forEach(([currency, basePrice]) => { %>
                <% if (currency === 'GBP') { %>
                  <!-- GBP is editable -->
                  <label><%= currency %> Total Price (Editable)</label>
                  <input type="number" name="tiers[<%= tier.id %>][subscriptions][<%= currency %>]"
                    value="<%= tier.subscriptions[currency].toFixed(2) %>"
                    step="0.01" min="0" class="calculated-price editable-gbp" data-currency="<%= currency %>" data-tier-id="<%= tier.id %>">
                <% } else { %>
                  <!-- Other currencies are calculated from GBP -->
                  <label><%= currency %> Total Price</label>
                  <input type="number" name="tiers[<%= tier.id %>][subscriptions][<%= currency %>]"
                    value="<%= tier.subscriptions[currency].toFixed(2) %>"
                    step="0.01" min="0" readonly class="calculated-price" data-currency="<%= currency %>" data-tier-id="<%= tier.id %>">
                <% } %>
              <% }) %>
              <button type="button" class="delete-tier" data-tier-id="<%= tier.id %>">Delete Tier</button>
            </div>
          <% }) %>
        </div>
      </form>
      <!-- Rounding Menu Added at the Bottom -->
      <div class="rounding-menu">
        <h3>Round Volume Tier Prices</h3>
        <div class="rounding-options">
          <div class="rounding-option">
            <input type="radio" id="round-10" name="rounding-base" value="10" checked>
            <label for="round-10">Nearest 10</label>
          </div>
          <div class="rounding-option">
            <input type="radio" id="round-50" name="rounding-base" value="50">
            <label for="round-50">Nearest 50</label>
          </div>
          <div class="rounding-option">
            <input type="radio" id="round-100" name="rounding-base" value="100">
            <label for="round-100">Nearest 100</label>
          </div>
        </div>
        <div class="rounding-buttons">
          <button type="button" id="round-up-button">Round Up</button>
          <button type="button" id="round-down-button">Round Down</button>
          <button type="button" id="round-nearest-button">Round to Nearest</button>
          <button type="button" id="undo-rounding-button">Undo Rounding</button>
        </div>
      </div>
      <div class="step-navigation">
        <button class="prev-step" data-prev="2">Previous: Base Prices</button> <!-- Updated data-prev -->
        <button class="next-step" data-next="4">Next: Edit Discounts</button> <!-- Updated data-next -->
      </div>
    </div>
    <!-- Step 4: Discounts (was Step 1) -->
    <div id="step4" class="step-container"> <!-- Changed ID -->
      <h2>Discount Settings</h2>
      <form id="discounts-form" action="/admin/updateDiscounts" method="POST">
          <div class="variable-grid">
          <% if (discountRules.commitments) { %>
              <% discountRules.commitments.forEach((commitment, index) => { %>
              <div class="variable-card">
                  <h3><%= commitment.name %></h3>
                  <label>Discount Percentage</label>
                  <!-- Use toString() for max precision in discount rules too -->
                  <input type="number" name="commitments[<%= commitment.key %>]"
                      value="<%= (commitment.value * 100).toString() %>" step="0.00000000000000000001" min="0" max="100">
              </div>
              <% }) %>
          <% } %>
          <div class="variable-card">
              <h3>Current Subscriber Discount</h3>
              <label>Additional Discount (%)</label>
              <!-- Use toString() for max precision -->
              <input type="number" name="currentSubscriber"
                  value="<%= (discountRules.currentSubscriber * 100).toString() %>" step="0.00000000000000000001" min="0" max="100">
          </div>
          </div>
      </form>
      <div class="step-navigation">
        <button class="prev-step" data-prev="3">Previous: Volume Pricing</button> <!-- Updated data-prev -->
        <button type="button" id="save-all-button">Save All Changes</button>
      </div>
    </div>
    <div class="button-group">
      <a href="/" class="secondary-button">Return to Home</a>
    </div>
<script>
  // Store original values for undo functionality
  let originalPrices = new Map();
  // Step navigation setup - Updated titles order
  const stepTitles = {
    1: "Step 1: Edit PPUs",
    2: "Step 2: Edit Base Prices",
    3: "Step 3: Edit Volume Pricing",
    4: "Step 4: Edit Discounts"
  };
  // Initialize with the active step from server (now maps to new step order)
  // The server-side activeStep logic might need adjustment if it relies on the old step numbers.
  // For now, we assume it correctly maps to the new step 1 (PPUs) as the default.
  const activeStep = <%= activeStep || 1 %>;
  // Set up step navigation
  function setupStepNavigation() {
    // Set the current step title
    document.getElementById('current-step-title').textContent = stepTitles[activeStep];
    // Show only the active step, hide others
    document.querySelectorAll('.step-container').forEach((container, index) => {
      container.style.display = (index + 1 === activeStep) ? 'block' : 'none';
    });
    // Next step navigation
    document.querySelectorAll('.next-step').forEach(button => {
      button.addEventListener('click', (e) => {
        const nextStep = parseInt(e.target.getAttribute('data-next'));
        document.querySelectorAll('.step-container').forEach(container => {
          container.style.display = 'none';
        });
        document.getElementById(`step${nextStep}`).style.display = 'block';
        document.getElementById('current-step-title').textContent = stepTitles[nextStep];
        // Update URL to reflect current step without reloading
        const url = new URL(window.location.href);
        url.searchParams.set('step', nextStep);
        window.history.pushState({ path: url.href }, '', url.href);
      });
    });
    // Previous step navigation
    document.querySelectorAll('.prev-step').forEach(button => {
      button.addEventListener('click', (e) => {
        const prevStep = parseInt(e.target.getAttribute('data-prev'));
        document.querySelectorAll('.step-container').forEach(container => {
          container.style.display = 'none';
        });
        document.getElementById(`step${prevStep}`).style.display = 'block';
        document.getElementById('current-step-title').textContent = stepTitles[prevStep];
        // Update URL to reflect current step without reloading
        const url = new URL(window.location.href);
        url.searchParams.set('step', prevStep);
        window.history.pushState({ path: url.href }, '', url.href);
      });
    });
  }
  // Tier deletion with AJAX to prevent page reload
  function setupTierDeletion() {
    document.querySelectorAll('.delete-tier').forEach(button => {
      button.addEventListener('click', async (e) => {
        e.preventDefault();
        const tierId = e.target.getAttribute('data-tier-id');
        if (confirm('Are you sure you want to delete this pricing tier?')) {
          try {
            const response = await fetch('/admin/deleteVolumeTier', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({ tierId })
            });
            const result = await response.json();
            if (result.success) {
              // Remove only the deleted tier from the UI
              const tierElement = e.target.closest('.variable-card');
              if (tierElement) {
                tierElement.remove();
              }
              // Show success message without leaving the page
              alert('Tier deleted successfully!');
              // Check if there are no tiers left and show appropriate message
              if (document.querySelectorAll('#volume-pricing-form .variable-card').length === 0) {
                const noTiersMsg = document.getElementById('no-tiers-message');
                if (noTiersMsg) noTiersMsg.style.display = 'block';
              }
            } else {
              alert(`Error: ${result.message}`);
            }
          } catch (err) {
            console.error('Tier deletion error:', err);
            alert('Failed to delete tier. Please try again.');
          }
        }
      });
    });
  }
  // Handle adding a new tier with AJAX
function setupAddTier() {
  const addTierForm = document.getElementById('add-tier-form');
  const userCountInput = document.getElementById('new-tier-user-count');
  const discountInput = document.getElementById('new-tier-discount');
  const addTierButton = document.getElementById('add-tier-button');
  // Update calculated prices when inputs change
  function updateCalculatedPrices() {
    const userCount = parseInt(userCountInput.value) || 0;
    const discount = parseFloat(discountInput.value) || 0; // Parse as float
    // Update calculated prices for each currency
    document.querySelectorAll('.new-tier-calculated-price').forEach(input => {
      const currency = input.getAttribute('data-currency');
      // Get base price from the form (now the hidden annual input)
      const basePriceInput = document.querySelector(`#base-prices-form input.base-annual-price-input[data-currency="${currency}"]`);
      const basePrice = basePriceInput ? parseFloat(basePriceInput.value) || 0 : 0;
      // Correct calculation: (user count * base price) * (1 - volume discount)
      const calculatedPrice = (userCount * basePrice * (1 - discount/100)).toFixed(2); // Calculation uses standard JS math
      input.value = calculatedPrice;
    });
  }
  // Add event listeners for input changes
  userCountInput.addEventListener('input', updateCalculatedPrices);
  discountInput.addEventListener('input', updateCalculatedPrices);
  // Handle form submission
  addTierForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    // Validate inputs
    if (!userCountInput.value || !discountInput.value) {
      alert('Please fill in all fields');
      return;
    }
    // Disable button to prevent multiple submissions
    addTierButton.disabled = true;
    addTierButton.textContent = 'Adding...';
    try {
      const formData = new FormData(addTierForm);
      const data = {};
      for (const [key, value] of formData) {
        data[key] = value;
      }
      const response = await fetch('/admin/addVolumeTier', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data)
      });
      const result = await response.json();
      if (result.success) {
        // Show success message and refresh the page
        alert('New tier added successfully!');
        window.location.reload();
      } else {
        alert(`Error: ${result.message}`);
      }
    } catch (err) {
      console.error('Error adding tier:', err);
      alert('Failed to add new tier. Please try again.');
    } finally {
      // Re-enable the button
      addTierButton.disabled = false;
      addTierButton.textContent = 'Add New Tier';
    }
  });
}
  // "Save All Changes" button functionality with protection against multiple clicks
  function setupSaveAllButton() {
    const saveButton = document.getElementById('save-all-button');
    let isSaving = false;
    saveButton.addEventListener('click', async () => {
      // Prevent multiple simultaneous saves
      if (isSaving) {
        return;
      }
      isSaving = true;
      saveButton.classList.add('saving');
      saveButton.textContent = 'Saving...';
      try {
        const forms = [
          document.getElementById('ppus-form'),           // Step 1
          document.getElementById('base-prices-form'),   // Step 2
          document.getElementById('volume-pricing-form'), // Step 3
          document.getElementById('discounts-form')      // Step 4
        ];
        for (const form of forms) {
          if (!form) continue;
          const formData = new FormData(form);
          const urlEncoded = new URLSearchParams();
          for (const [key, value] of formData) {
            urlEncoded.append(key, value);
          }
          const response = await fetch(form.action, {
            method: 'POST',
            body: urlEncoded,
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            }
          });
          if (!response.ok) {
            const text = await response.text();
            throw new Error(`Failed to save ${form.id}: ${response.status} ${text.substring(0, 100)}...`);
          }
        }
        // After all forms are saved successfully, update the URL to show success
        const url = new URL(window.location.href);
        url.searchParams.set('step', '4'); // Redirect to the last step (Discounts) after saving
        if (url.searchParams.get('message')) {
          url.searchParams.set('message', 'All changes saved successfully!');
        } else {
          url.searchParams.append('message', 'All changes saved successfully!');
        }
        // Update URL without reloading
        window.history.pushState({ path: url.href }, '', url.href);
        // Show success message
        alert('All changes saved successfully!');
      } catch (error) {
        console.error('Save error:', error);
        alert(`Error saving changes: ${error.message}`);
      } finally {
        // Reset the button state
        isSaving = false;
        saveButton.classList.remove('saving');
        saveButton.textContent = 'Save All Changes';
      }
    });
  }
  // Initialize calculations on page load
  function calculatePrices() {
    // --- Updated Base Price Calculation Logic (Monthly Input -> Annual Stored/Displayed) ---
    // Listen for changes on the *monthly* base price inputs
    const baseMonthlyPriceInputs = document.querySelectorAll('#base-prices-form input[name^="monthlySubscriptions"]');
    baseMonthlyPriceInputs.forEach(input => {
        // Trigger calculation on input change
        input.addEventListener('input', function() {
            const currency = this.name.match(/\[(.*?)\]/)[1];
            const monthlyPrice = parseFloat(this.value) || 0;
            const calculatedAnnualPrice = (monthlyPrice * 12); // Calculate annual
            // Update the hidden annual price input (this is what gets submitted)
            const annualPriceInput = document.querySelector(`#base-prices-form input.base-annual-price-input[data-currency="${currency}"]`);
            if (annualPriceInput) {
                annualPriceInput.value = calculatedAnnualPrice.toFixed(2); // Store annual with 2 decimals
            }
            // Update the displayed annual price for confirmation
            const annualPriceDisplay = document.querySelector(`#base-prices-form input.base-calculated-annual-price-display[data-currency="${currency}"]`);
            if (annualPriceDisplay) {
                annualPriceDisplay.value = calculatedAnnualPrice.toFixed(2); // Display annual with 2 decimals
            }
            // --- Also update related volume pricing calculations ---
            // Find all volume pricing inputs for this currency
            document.querySelectorAll(`#volume-pricing-grid input[data-currency="${currency}"]`).forEach(volumeInput => {
                const tierId = volumeInput.getAttribute('data-tier-id');
                if (tierId) {
                    // Get user count and discount for this tier
                    const userCountInput = document.querySelector(`input[name="tiers[${tierId}][userCount]"]`);
                    const discountInput = document.querySelector(`input[name="tiers[${tierId}][volumeDiscount]"]`);
                    const userCount = userCountInput ? parseInt(userCountInput.value) || 0 : 0;
                    const discount = discountInput ? parseFloat(discountInput.value) || 0 : 0; // Parse discount from input (already %)
                    // Recalculate volume price using the NEW annual base price
                    const calculatedVolumePrice = (userCount * calculatedAnnualPrice * (1 - discount/100)).toFixed(2); // Calculation uses standard JS math
                    volumeInput.value = calculatedVolumePrice;
                }
            });
            // --- Also update the new tier form calculations ---
            const newTierPriceInput = document.querySelector(`#add-tier-form input[data-currency="${currency}"]`);
            if (newTierPriceInput) {
                const userCountInput = document.getElementById('new-tier-user-count');
                const discountInput = document.getElementById('new-tier-discount');
                const userCount = parseInt(userCountInput.value) || 0;
                const discount = parseFloat(discountInput.value) || 0; // Parse discount from input (already %)
                // Recalculate new tier price using the NEW annual base price
                const calculatedNewTierPrice = (userCount * calculatedAnnualPrice * (1 - discount/100)).toFixed(2); // Calculation uses standard JS math
                newTierPriceInput.value = calculatedNewTierPrice;
            }
        });
    });
    // --- Keep the existing Volume Discount, User Count, and GBP Price change calculations ---
    // They should work correctly as they read the *annual* base price from the hidden input or recalculate it.
    // Volume discount calculation logic
    document.querySelectorAll('#volume-pricing-form input[name$="[volumeDiscount]"]').forEach(discountInput => {
        discountInput.addEventListener('input', function() {
        const tierId = this.getAttribute('data-tier-id');
        if (tierId) {
          const discount = parseFloat(this.value) || 0; // Get discount % from input
          const userCountInput = document.querySelector(`input[name="tiers[${tierId}][userCount]"]`);
          const userCount = userCountInput ? parseInt(userCountInput.value) || 0 : 0;
          // Update all currency prices for this tier - read from hidden annual input
          document.querySelectorAll('#base-prices-form input.base-annual-price-input[name^="subscriptions"]').forEach(basePriceInput => {
            const currency = basePriceInput.name.match(/\[(.*?)\]/)[1];
            const basePrice = parseFloat(basePriceInput.value) || 0;
            // Correct calculation: (user count * base price) * (1 - volume discount)
            const calculatedPrice = (userCount * basePrice * (1 - discount/100)).toFixed(2); // Calculation uses standard JS math
            const volumePriceInput = document.querySelector(`input[name="tiers[${tierId}][subscriptions][${currency}]"]`);
            if (volumePriceInput) {
              volumePriceInput.value = calculatedPrice;
            }
          });
        }
      });
    });
    // User count calculation logic
    document.querySelectorAll('#volume-pricing-form input[name$="[userCount]"]').forEach(userCountInput => {
        userCountInput.addEventListener('input', function() {
        const tierId = this.name.match(/tiers\[(\d+)\]/)?.[1];
        if (tierId) {
          const userCount = parseInt(this.value) || 0;
          const discountInput = document.querySelector(`input[name="tiers[${tierId}][volumeDiscount]"]`);
          const discount = discountInput ? parseFloat(discountInput.value) || 0 : 0; // Get discount % from input
          // Update all currency prices for this tier - read from hidden annual input
          document.querySelectorAll('#base-prices-form input.base-annual-price-input[name^="subscriptions"]').forEach(basePriceInput => {
            const currency = basePriceInput.name.match(/\[(.*?)\]/)[1];
            const basePrice = parseFloat(basePriceInput.value) || 0;
            // Correct calculation: (user count * base price) * (1 - volume discount)
            const calculatedPrice = (userCount * basePrice * (1 - discount/100)).toFixed(2); // Calculation uses standard JS math
            const volumePriceInput = document.querySelector(`input[name="tiers[${tierId}][subscriptions][${currency}]"]`);
            if (volumePriceInput) {
              volumePriceInput.value = calculatedPrice;
            }
          });
        }
      });
    });
    // GBP price change calculation logic - when GBP price is edited, update other currencies and volume discount
    document.querySelectorAll('#volume-pricing-grid input[data-currency="GBP"].editable-gbp').forEach(gbpInput => {
        gbpInput.addEventListener('input', function() {
        const tierId = this.getAttribute('data-tier-id');
        if (tierId) {
          const gbpPrice = parseFloat(this.value) || 0;
          // Get user count for this tier
          const userCountInput = document.querySelector(`input[name="tiers[${tierId}][userCount]"]`);
          const userCount = userCountInput ? parseInt(userCountInput.value) || 0 : 0;
          // Get base GBP price - read from hidden annual input
          const baseGbpPriceInput = document.querySelector('#base-prices-form input.base-annual-price-input[data-currency="GBP"]');
          const baseGbpPrice = baseGbpPriceInput ? parseFloat(baseGbpPriceInput.value) || 0 : 0;
          // Calculate volume discount: 1 - (editedPrice / (basePrice * userCount))
          if (userCount > 0 && baseGbpPrice > 0) {
            const calculatedDiscount = 1 - (gbpPrice / (baseGbpPrice * userCount));
            const discountPercent = Math.max(0, Math.min(100, calculatedDiscount * 100)); // Clamp between 0 and 100
            // Update the discount input with maximum JS precision using toString()
            const discountInput = document.querySelector(`input[name="tiers[${tierId}][volumeDiscount]"]`);
            if (discountInput) {
              discountInput.value = discountPercent.toString(); // Use toString() for display
            }
          }
          // Update EUR and USD prices based on GBP and currency rates
          <% Object.entries(basePrices.subscriptions).forEach(([currency, basePrice]) => { %>
            <% if (currency !== 'GBP') { %>
              const <%= currency.toLowerCase() %>Rate = <%= (rawCurrencies[currency] / rawCurrencies.GBP).toFixed(4) %>;
              const <%= currency.toLowerCase() %>Price = (gbpPrice * <%= currency.toLowerCase() %>Rate).toFixed(2);
              const <%= currency.toLowerCase() %>Input = document.querySelector(`input[name="tiers[${tierId}][subscriptions][<%= currency %>]"]`);
              if (<%= currency.toLowerCase() %>Input) {
                <%= currency.toLowerCase() %>Input.value = <%= currency.toLowerCase() %>Price;
              }
            <% } %>
          <% }) %>
        }
      });
    });
    // --- End of Updated Base Price Calculation Logic ---
  }
  // --- New Rounding Functions ---
  function setupRounding() {
    const roundUpButton = document.getElementById('round-up-button');
    const roundDownButton = document.getElementById('round-down-button');
    const roundNearestButton = document.getElementById('round-nearest-button');
    const undoRoundingButton = document.getElementById('undo-rounding-button');
    // Initialize original prices map
    function initializeOriginalPrices() {
      document.querySelectorAll('#volume-pricing-grid input.calculated-price[type="number"]').forEach(input => {
        const key = input.name;
        if (!originalPrices.has(key)) {
          originalPrices.set(key, input.value);
        }
      });
    }
    function roundPrices(method) {
        const roundingBaseInputs = document.querySelectorAll('input[name="rounding-base"]');
        let roundingBase = 10; // Default
        for (const input of roundingBaseInputs) {
            if (input.checked) {
                roundingBase = parseFloat(input.value);
                break;
            }
        }
        // Find all calculated price inputs in the volume pricing grid
        const priceInputs = document.querySelectorAll('#volume-pricing-grid input.calculated-price[type="number"]');
        priceInputs.forEach(input => {
            const originalValue = parseFloat(input.value);
            if (isNaN(originalValue)) return; // Skip if not a valid number
            let roundedValue;
            const factor = roundingBase;
            switch (method) {
                case 'up':
                    roundedValue = Math.ceil(originalValue / factor) * factor;
                    break;
                case 'down':
                    roundedValue = Math.floor(originalValue / factor) * factor;
                    break;
                case 'nearest':
                default:
                    roundedValue = Math.round(originalValue / factor) * factor;
                    break;
            }
            // Update the input value
            input.value = roundedValue.toFixed(2);
        });
        alert(`Prices rounded (${method}) to the nearest ${roundingBase}.`);
    }
    function undoRounding() {
      document.querySelectorAll('#volume-pricing-grid input.calculated-price[type="number"]').forEach(input => {
        const key = input.name;
        if (originalPrices.has(key)) {
          input.value = originalPrices.get(key);
        }
      });
      alert('Rounding undone. Prices restored to original values.');
    }
    // Initialize original prices when page loads
    document.addEventListener('DOMContentLoaded', initializeOriginalPrices);
    if (roundUpButton) roundUpButton.addEventListener('click', () => roundPrices('up'));
    if (roundDownButton) roundDownButton.addEventListener('click', () => roundPrices('down'));
    if (roundNearestButton) roundNearestButton.addEventListener('click', () => roundPrices('nearest'));
    if (undoRoundingButton) undoRoundingButton.addEventListener('click', undoRounding);
  }
  // Initialize everything when page loads
  document.addEventListener('DOMContentLoaded', () => {
    setupStepNavigation();
    setupTierDeletion();
    setupAddTier();
    setupSaveAllButton();
    calculatePrices();
    setupRounding(); // Initialize rounding functionality
    // Handle message display from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const message = urlParams.get('message');
    if (message) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message';
      messageDiv.textContent = message;
      document.querySelector('.titleDiv').insertBefore(messageDiv, document.querySelector('.titleDiv h1').nextSibling);
      // Remove message from URL without reloading
      const cleanUrl = window.location.pathname + window.location.search.replace(/([&?])message=[^&]*/g, '').replace(/(&{2,})/g, '&').replace(/[?&]$/, '');
      window.history.replaceState({}, document.title, cleanUrl);
    }
  });
</script>
</body>
</html>